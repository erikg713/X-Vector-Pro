import os
import threading
import importlib.util
import customtkinter as ctk
from tkinter import messagebox, simpledialog
from utils.logger import log_to_central
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

EXPLOIT_DIR = "core/exploits"
REPORT_FILE = "exploit_report.txt"

class ExploitsTab:
    def __init__(self, parent):
        self.parent = parent
        self.exploit_modules = {}
        self.execution_history = {}

        # Email configuration
        self.email_recipient = "recipient@example.com"
        self.email_sender = "sender@example.com"
        self.email_password = "password"
        
        # Initialize UI components
        self._setup_ui()

        # Load available exploits dynamically
        self._load_exploit_modules()

    def _setup_ui(self):
        # Header and Target Input
        ctk.CTkLabel(self.parent, text="Target IP or Domain", font=("Segoe UI", 14)).pack(pady=(10, 4))
        self.target_entry = ctk.CTkEntry(self.parent, width=500)
        self.target_entry.pack(pady=(0, 10))

        # Output console for logs
        self.output_console = ctk.CTkTextbox(self.parent, width=900, height=420, font=("Consolas", 12))
        self.output_console.pack(pady=10)
        self._log("[*] Exploits tab initialized.\n")

        # Frame for buttons (run individual exploits)
        self.button_frame = ctk.CTkFrame(self.parent)
        self.button_frame.pack(pady=(10, 5))

        # Run all exploits button
        ctk.CTkButton(
            self.parent,
            text="Run All Exploits",
            fg_color="#1f6feb",
            hover_color="#1953c5",
            command=self._run_all_exploits,
            width=180
        ).pack(pady=(5, 10))

        # CVE exploit selection and execution
        ctk.CTkButton(
            self.parent,
            text="Run CVE Exploit by ID",
            command=self._run_cve_exploit,
            width=180
        ).pack(pady=(5, 10))

        # History Button
        ctk.CTkButton(
            self.parent,
            text="View History",
            command=self._view_execution_history,
            width=180
        ).pack(pady=(5, 10))

    def _log(self, message):
        """Add log message to the output console and log file"""
        self.output_console.insert("end", f"{message}\n")
        self.output_console.see("end")
        
        # Save log message to file
        with open(REPORT_FILE, "a") as f:
            f.write(f"{message}\n")

    def _load_exploit_modules(self):
        """Dynamically load all available exploits from the exploit directory."""
        self._log("[*] Discovering exploit modules...\n")

        for file in sorted(os.listdir(EXPLOIT_DIR)):
            if file.startswith("exploit_") and file.endswith(".py"):
                module_name = file[:-3]  # Remove .py extension
                file_path = os.path.join(EXPLOIT_DIR, file)

                try:
                    # Dynamically load the exploit module
                    spec = importlib.util.spec_from_file_location(module_name, file_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

                    if hasattr(module, "run"):
                        self.exploit_modules[module_name] = module
                        self._add_exploit_button(module_name)
                        self._log(f"[+] Loaded: {module_name}")
                    else:
                        self._log(f"[-] Skipped (no run() method): {module_name}")
                except Exception as e:
                    self._log(f"[!] Error loading {module_name}: {e}")

        if not self.exploit_modules:
            self._log("[!] No valid exploits found in the directory.")

    def _add_exploit_button(self, name):
        """Add a button for each exploit in the exploit module list."""
        exploit_button = ctk.CTkButton(
            self.button_frame,
            text=f"Run {name}",
            command=lambda n=name: threading.Thread(target=self._run_exploit, args=(n,), daemon=True).start(),
            width=240
        )
        exploit_button.pack(pady=2)

    def _run_exploit(self, name):
        """Run a specific exploit and handle its results."""
        target = self.target_entry.get().strip()
        if not target:
            messagebox.showwarning("Target Missing", "Please enter a target IP or domain.")
            return

        # Check if additional configuration is required
        exploit = self.exploit_modules[name]
        exploit_config = self._get_exploit_configuration(name)

        self._log(f"\n[*] Running {name} against {target}...")

        try:
            result = exploit.run(target, **exploit_config)
            log_to_central(f"[+] {name} executed on {target}")
            self._log(f"[+] {name} result:\n{result}")
            self._store_execution_history(name, target, "Success", result)
            
            # Auto-Report after execution
            self._send_email_report(name, target, "Success", result)
            self._store_execution_history(name, target, "Success", result)
        except Exception as e:
            self._log(f"[-] {name} failed: {e}")
            self._send_email_report(name, target, "Failed", str(e))
            self._store_execution_history(name, target, "Failed", str(e))

    def _run_all_exploits(self):
        """Run all the loaded exploits on the specified target."""
        target = self.target_entry.get().strip()
        if not target:
            messagebox.showwarning("Target Missing", "Please enter a target IP or domain.")
            return

        for name in self.exploit_modules:
            threading.Thread(target=self._run_exploit, args=(name,), daemon=True).start()

        self._log("\n[*] Running all exploits...")

    def _get_exploit_configuration(self, name):
        """Allow user to configure parameters for certain exploits if needed."""
        exploit = self.exploit_modules[name]
        config_params = {}

        if hasattr(exploit, "get_required_parameters"):
            required_params = exploit.get_required_parameters()

            for param, prompt in required_params.items():
                value = simpledialog.askstring("Exploit Configuration", f"Enter {param} ({prompt}):")
                config_params[param] = value

        return config_params

    def _run_cve_exploit(self):
        """Allow the user to run an exploit targeting a specific CVE by ID."""
        cve_id = simpledialog.askstring("CVE ID", "Enter the CVE ID to exploit (e.g., CVE-2020-1234):")
        if not cve_id:
            messagebox.showwarning("CVE ID Missing", "Please enter a valid CVE ID.")
            return

        # Find the exploits related to this CVE
        exploits_to_run = [name for name, module in self.exploit_modules.items() if cve_id in module.get_cve_ids()]
        if not exploits_to_run:
            messagebox.showwarning("No Exploits Found", f"No exploits found for {cve_id}.")
            return

        for name in exploits_to_run:
            threading.Thread(target=self._run_exploit, args=(name,), daemon=True).start()

        self._log(f"\n[*] Running exploits for CVE {cve_id}...")

    def _store_execution_history(self, exploit_name, target, status, result):
        """Store the execution history."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.execution_history[timestamp] = {
            "exploit": exploit_name,
            "target": target,
            "status": status,
            "result": result
        }

    def _view_execution_history(self):
        """Display the history of exploit executions."""
        history_window = ctk.CTkToplevel(self.parent)
        history_window.title("Execution History")

        history_text = ctk.CTkTextbox(history_window, width=600, height=400, font=("Consolas", 12))
        history_text.pack(pady=10)

        if not self.execution_history:
            history_text.insert("end", "[*] No execution history available.\n")
        else:
            for timestamp, details in self.execution_history.items():
                history_text.insert(
                    "end", f"{timestamp} | {details['exploit']} | {details['target']} | {details['status']}\n"
                )

    def _send_email_report(self, exploit_name, target, status, result):
        """Send an email with the execution results."""
        try:
            # Compose email
            subject = f"Exploit Execution Report - {exploit_name} on {target}"
            body = f"Exploit: {exploit_name}\nTarget: {target}\nStatus: {status}\nResult:\n{result}"

            msg = MIMEMultipart()
            msg['From'] = self.email_sender
            msg['To'] = self.email_recipient
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))

            # Send email using SMTP server
            with smtplib.SMTP('smtp.gmail.com', 587) as server:
                server.starttls()
                server.login(self.email_sender, self.email_password)
                server.sendmail(self.email_sender, self.email_recipient, msg.as_string())

            self._log("[*] Report sent via email successfully.")
        except Exception as e:
            self._log(f"[!] Failed to send email: {e}")
