# gui/tabs/exploits_tab.py

import os
import json
import random
import threading
from tkinter import messagebox
import customtkinter as ctk
from core.exploits import exploit_manager
from utils.logger import log
from gui.dashboard import show_toast
from tkinter import ttk

class ExploitsTab(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master)
        self.status_var = ctk.StringVar(value="Idle")
        self.stealth_var = ctk.BooleanVar(value=False)
        self.use_tor_var = ctk.BooleanVar(value=False)
        self.use_proxy_var = ctk.BooleanVar(value=False)
        self.build_ui()

    def build_ui(self):
        ctk.CTkLabel(self, text="Exploits", font=("Segoe UI", 18, "bold"))\
            .pack(pady=(10, 5))

        # Stealth / Proxy options
        opts = ctk.CTkFrame(self)
        opts.pack(fill="x", padx=20, pady=(0, 10))
        ctk.CTkCheckBox(opts, text="Stealth Mode", variable=self.stealth_var).pack(side="left", padx=5)
        ctk.CTkCheckBox(opts, text="Use Tor", variable=self.use_tor_var).pack(side="left", padx=5)
        ctk.CTkCheckBox(opts, text="Rotate Proxies", variable=self.use_proxy_var).pack(side="left", padx=5)

        # Start button
        self.start_button = ctk.CTkButton(self, text="Start Exploit", command=self.start_exploit_threaded)
        self.start_button.pack(pady=(0, 10))

        # Status
        ctk.CTkLabel(self, textvariable=self.status_var, text_color="gray", font=("Segoe UI", 12))\
            .pack(pady=(0, 10))

        # Exploit output (Invisible in stealth mode)
        self.exploit_box = ctk.CTkTextbox(self, height=400, wrap="word")
        self.exploit_box.pack(padx=20, pady=10, fill="both", expand=True)
        self.exploit_box.insert("end", "Exploits will appear here...\n")
        self.exploit_box.configure(state="disabled")

        # Progress Spinner (Invisible operation tweak)
        self.spinner = ttk.Progressbar(self, orient="horizontal", length=300, mode="indeterminate")
        self.spinner.pack(padx=20, pady=10)
        self.spinner.place_forget()  # Hide by default

    def start_exploit_threaded(self):
        threading.Thread(target=self.run_exploit, daemon=True).start()

    def run_exploit(self):
        self.show_status("Initializing Exploit...")
        self.set_button_state(False)
        try:
            self.apply_network_cloaking()

            exploits = exploit_manager.get_exploits()
            for exploit in exploits:
                result = exploit_manager.run_exploit(exploit)
                if self.stealth_var.get():
                    self.encrypt_logs(exploit, result)
                else:
                    self.append_exploit(f"{exploit} Result: {result}\n")

            show_toast(self.master, "Exploit process completed.")

        except Exception as e:
            log.error(f"Exploit error: {e}")
            self.append_exploit(f"[ERROR] {e}\n")
            show_toast(self.master, f"Exploit error: {e}")
        finally:
            self.set_button_state(True)
            self.show_status("Idle")
            self.show_spinner(False)  # Hide the spinner

    def apply_network_cloaking(self):
        # Tor
        if self.use_tor_var.get():
            if socks:
                try:
                    socks.set_default_proxy(socks.SOCKS5, "127.0.0.1", 9050)
                    socket.socket = socks.socksocket
                    log.info("Tor proxy applied")
                except Exception as e:
                    log.error(f"Tor setup failed: {e}")
                    show_toast(self.master, "Tor setup failed")
            else:
                log.warning("PySocks not installed")
                show_toast(self.master, "Install PySocks for Tor support")

        # Proxy rotation
        if self.use_proxy_var.get():
            try:
                with open("proxies.txt") as f:
                    proxies = [p.strip() for p in f if p.strip()]
                if not proxies:
                    raise ValueError("Proxy list empty")
                proxy = random.choice(proxies)
                os.environ["HTTP_PROXY"] = proxy
                os.environ["HTTPS_PROXY"] = proxy
                log.info(f"Rotated proxy: {proxy}")
            except Exception as e:
                log.error(f"Proxy rotation failed: {e}")
                show_toast(self.master, "Proxy rotation failed")

    def encrypt_logs(self, exploit, result):
        try:
            from utils.logger import encrypt_log
            payload = json.dumps({"exploit": exploit, "result": result})
            encrypt_log(payload, f"{exploit}_result.enc")
            log.info(f"Encrypted exploit result to {exploit}_result.enc")
        except Exception as e:
            log.error(f"Log encryption failed: {e}")
            show_toast(self.master, "Log encryption failed")

    def append_exploit(self, text):
        self.exploit_box.configure(state="normal")
        self.exploit_box.insert("end", text)
        self.exploit_box.see("end")
        self.exploit_box.configure(state="disabled")

    def show_status(self, text):
        self.status_var.set(text)

    def set_button_state(self, enabled: bool):
        self.start_button.configure(state="normal" if enabled else "disabled")

    def show_spinner(self, show: bool):
        if show:
            self.spinner.place(x=100, y=320)  # Position it appropriately
            self.spinner.start()
        else:
            self.spinner.place_forget()  # Hide the spinner
            self.spinner.stop()
ctk.CTkLabel(exploit_tab, text="Target XML-RPC URL").pack(pady=5)
exploit_target_entry = ctk.CTkEntry(exploit_tab, width=700)
exploit_target_entry.insert(0, "https://example.com/xmlrpc.php")
exploit_target_entry.pack()

ctk.CTkLabel(exploit_tab, text="Victim URL to Ping").pack(pady=5)
exploit_victim_entry = ctk.CTkEntry(exploit_tab, width=700)
exploit_victim_entry.insert(0, "http://victim.com")
exploit_victim_entry.pack()

ctk.CTkButton(exploit_tab, text="Launch Pingback Exploit",
              command=lambda: threading.Thread(target=run_pingback_exploit).start()).pack(pady=10)

exploit_output = ctk.CTkTextbox(exploit_tab, height=300, width=800)
exploit_output.pack()
