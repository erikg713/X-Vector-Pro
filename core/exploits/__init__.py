import os
import importlib
import logging
logging.basicConfig(level=logging.INFO)

logging.error(f"Failed to load exploit {name}: {e}")
logging.warning(f"Exploit {name} missing metadata, skipping.")
def load_exploits(filter_tags=None, only_enabled=True):
    modules = []
    exploits_dir = os.path.dirname(__file__)
    for file in os.listdir(exploits_dir):
        if file.endswith(".py") and file != "__init__.py":
            name = file[:-3]
            try:
                mod = importlib.import_module(f"exploits.{name}")

                # Check if module has 'metadata'
                if not hasattr(mod, "metadata"):
                    print(f"[!] Exploit {name} missing metadata, skipping.")
                    continue

                meta = mod.metadata

                # Skip if disabled
                if only_enabled and not meta.get("enabled", False):
                    continue

                # Filter by tags if specified
                if filter_tags:
                    exploit_tags = meta.get("tags", [])
                    if not any(tag in exploit_tags for tag in filter_tags):
                        continue

                modules.append((meta.get("name", name), mod))
            except Exception as e:
                print(f"[!] Failed to load exploit {name}: {e}")
    return modules

def run_all_exploits(target_url, filter_tags=None):
    results = []
    exploits = load_exploits(filter_tags=filter_tags)

    for name, mod in exploits:
        print(f"[*] Running exploit: {name}")
        try:
            result = mod.run_exploit(target_url)
            results.append((name, result))
        except Exception as e:
            print(f"[!] Exploit {name} failed: {e}")
            results.append((name, None))

    return results
try:
    mod = importlib.import_module(f"exploits.{name}")
except ModuleNotFoundError as e:
    logging.error(f"Module {name} not found: {e}")
except Exception as e:
    logging.error(f"Failed to load module {name}: {e}")
    required_keys = ["enabled", "tags", "name"]
for key in required_keys:
    if key not in meta:
        logging.warning(f"Key {key} missing in metadata for {name}, skipping.")
        continue
   def load_exploits(filter_tags=None, only_enabled=True):
    """
    Dynamically loads exploit modules based on filter criteria.

    Args:
        filter_tags (list): List of tags to filter exploits.
        only_enabled (bool): Whether to load only enabled exploits.

    Returns:
        list: List of loaded exploit modules.
    """     
if verbose:
    logging.info(f"Loaded exploit: {name}")
