import os
import importlib
import logging
from core.logger import log_event

log_event("scan", {"target": "example.com", "status": "open ports found"}, level="info", write_structured_file=True)
from utils.logger import save_hit, log_event
from typing import List, Optional, Tuple, Dict

# Configure detailed logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

def validate_metadata(meta: Dict[str, any], required_keys: List[str]) -> bool:
    """
    Validate that all required keys exist in the module metadata.

    Args:
        meta (dict): The metadata dictionary to validate.
        required_keys (list): List of required keys.

    Returns:
        bool: True if all required keys are present, False otherwise.
    """
    missing_keys = [key for key in required_keys if key not in meta]
    if missing_keys:
        logging.warning("Missing metadata keys: %s", ', '.join(missing_keys))
        return False
    return True

def load_exploits(filter_tags: Optional[List[str]] = None, only_enabled: bool = True) -> List[Tuple[str, any]]:
    """
    Dynamically loads exploit modules based on filter criteria.

    Args:
        filter_tags (list, optional): List of tags to filter exploits. Defaults to None.
        only_enabled (bool): Whether to load only enabled exploits. Defaults to True.

    Returns:
        list: List of tuples containing exploit names and their modules.
    """
    modules = []
    exploits_dir = os.path.dirname(__file__)
    logging.debug("Searching for exploit modules in directory: %s", exploits_dir)

    for file in os.listdir(exploits_dir):
        if file.endswith(".py") and file != "__init__.py":
            name = file[:-3]
            try:
                logging.debug("Importing module: %s", name)
                mod = importlib.import_module(f"core.exploits.{name}")
                
                # Validate metadata
                meta = getattr(mod, "metadata", None)
                if not meta:
                    logging.warning("Exploit %s missing metadata, skipping.", name)
                    continue

                if only_enabled and not meta.get("enabled", False):
                    logging.info("Exploit %s is disabled, skipping.", name)
                    continue

                if filter_tags and not set(filter_tags).intersection(meta.get("tags", [])):
                    logging.info("Exploit %s does not match filter tags %s, skipping.", name, filter_tags)
                    continue

                # Add to modules list
                modules.append((meta.get("name", name), mod))

            except ModuleNotFoundError as e:
                logging.error("Module %s not found: %s", name, e)
            except Exception as e:
                logging.error("Failed to load module %s: %s", name, e)
    logging.info("Loaded %d exploit modules.", len(modules))
    return modules

def run_all_exploits(target_url: str, filter_tags: Optional[List[str]] = None) -> List[Tuple[str, Optional[any]]]:
    """
    Runs all loaded exploits on the specified target URL.

    Args:
        target_url (str): The target URL to run exploits against.
        filter_tags (list, optional): List of tags to filter exploits. Defaults to None.

    Returns:
        list: List of tuples containing exploit names and their results.
    """
    results = []
    logging.info("Starting exploit run against target: %s", target_url)
    exploits = load_exploits(filter_tags=filter_tags)

    for name, mod in exploits:
        logging.info("Running exploit: %s", name)
        try:
            result = mod.run_exploit(target_url)
            logging.info("Exploit %s completed successfully.", name)
            results.append((name, result))
        except Exception as e:
            logging.error("Exploit %s failed: %s", name, e)
            results.append((name, None))

    logging.info("Completed running all exploits.")
    return results
