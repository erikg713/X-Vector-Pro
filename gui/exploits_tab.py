import os
import importlib.util
import customtkinter as ctk
from tkinter import messagebox
from tkinter.scrolledtext import ScrolledText
from utils import logger

logger.log("[+] Exploit launched", "info")
logger.log("[!] Warning: timeout", "warn")
logger.log("[+] HIT FOUND: admin:1234", "hit")

class ExploitsTab:
    def __init__(self, parent):
        self.parent = parent
        self.target = ctk.StringVar()
        self.filter_tag = ctk.StringVar(value="all")
        self.exploits_dir = "exploits"
        self.exploit_modules = []
        self.filtered_modules = []

        self.build_ui()
        self.load_exploits()

    def build_ui(self):
        frame = ctk.CTkFrame(self.parent)
        frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Target entry
        target_label = ctk.CTkLabel(frame, text="Target IP/Domain:")
        target_label.grid(row=0, column=0, sticky="w", padx=5)
        self.target_entry = ctk.CTkEntry(frame, textvariable=self.target, width=300)
        self.target_entry.grid(row=0, column=1, columnspan=2, pady=5, sticky="w")

        # Tag filter dropdown
        self.filter_menu = ctk.CTkOptionMenu(frame, variable=self.filter_tag, values=["all"], command=self.filter_by_tag)
        self.filter_menu.grid(row=0, column=3, padx=10)

        # Exploit list
        self.exploit_listbox = ctk.CTkTextbox(frame, height=150, width=400)
        self.exploit_listbox.grid(row=1, column=0, columnspan=4, pady=10, padx=5, sticky="ew")
        self.exploit_listbox.configure(state="disabled")

        # Buttons
        run_selected_btn = ctk.CTkButton(frame, text="Run Selected", command=self.run_selected)
        run_selected_btn.grid(row=2, column=0, pady=5)

        run_all_btn = ctk.CTkButton(frame, text="Run All", fg_color="green", command=self.run_all)
        run_all_btn.grid(row=2, column=1, pady=5)

        reload_btn = ctk.CTkButton(frame, text="Reload", command=self.load_exploits)
        reload_btn.grid(row=2, column=2, pady=5)

        # Output box
        self.output_box = ScrolledText(frame, height=20, bg="#1e1e1e", fg="#eeeeee", insertbackground="#eeeeee")
        self.output_box.grid(row=3, column=0, columnspan=4, pady=10, sticky="nsew")

        frame.grid_columnconfigure(3, weight=1)
        frame.grid_rowconfigure(3, weight=1)

    def load_exploits(self):
        self.exploit_modules = []
        tag_set = set()
        self.exploit_listbox.configure(state="normal")
        self.exploit_listbox.delete("1.0", "end")

        for file in os.listdir(self.exploits_dir):
            if file.endswith(".py") and not file.startswith("__"):
                path = os.path.join(self.exploits_dir, file)
                name = file[:-3]
                spec = importlib.util.spec_from_file_location(name, path)
                module = importlib.util.module_from_spec(spec)
                try:
                    spec.loader.exec_module(module)
                    tags = getattr(module, "tags", ["misc"])
                    self.exploit_modules.append((name, module, tags))
                    self.exploit_listbox.insert("end", f"{name} [tags: {', '.join(tags)}]\n")
                    tag_set.update(tags)
                except Exception as e:
                    self.output_box.insert("end", f"[!] Error loading {name}: {e}\n")

        # Update filter dropdown
        self.filter_menu.configure(values=["all"] + sorted(tag_set))
        self.filter_by_tag()

        self.exploit_listbox.configure(state="disabled")

    def filter_by_tag(self, selected=None):
        selected = self.filter_tag.get()
        self.filtered_modules = [
            (name, mod) for (name, mod, tags) in self.exploit_modules
            if selected == "all" or selected in tags
        ]

    def run_selected(self):
        lines = self.exploit_listbox.get("1.0", "end").strip().splitlines()
        selected_names = [line.split(" ")[0] for line in lines if line.strip()]
        for name, mod, _ in self.exploit_modules:
            if name in selected_names:
                self.execute_exploit(name, mod)

    def run_all(self):
        target = self.target.get().strip()
        if not target:
            messagebox.showerror("Missing Target", "Please enter a target.")
            return
        for name, mod in self.filtered_modules:
            self.execute_exploit(name, mod, target)

    def execute_exploit(self, name, module, target=None):
        try:
            output = module.run(target)
            self.print_output(f"[+] {name} SUCCESS\n{output}\n", color="green")
        except Exception as e:
            self.print_output(f"[-] {name} FAILED: {e}\n", color="red")

    def print_output(self, message, color="white"):
        tag = f"tag_{color}"
        self.output_box.tag_config(tag, foreground=color)
        self.output_box.insert("end", message, tag)
        self.output_box.see("end")
